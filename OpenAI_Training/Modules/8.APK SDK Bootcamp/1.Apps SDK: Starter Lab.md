Apps SDK: Starter Lab
Goal: build a tiny ChatGPT App end to end: an MCP server with tools, plus a widget UI that renders inside ChatGPT.
Completion time: ~25 minutes.
What you'll build:
An MCP server (server.js) that exposes tools and a widget template
A single-file widget (public/todo-widget.html)
Two tools: add_todo and complete_todo
Tool output that includes structuredContent.tasks, which is what your widget reads via window.openai.toolOutput
Prerequisites
Node.js 18+ installed
Access to ChatGPT Developer Mode (Settings -> Apps & Connectors -> Developer mode)
A way to expose a localhost over HTTPS (for example ngrok)
Step 0: Project setup
mkdir apps-sdk-todo
cd apps-sdk-todo
mkdir public
npm init -y
Update package.json so Node runs ESM:
{
  "type": "module"
}
Step 1: Install the MCP SDK
npm install @modelcontextprotocol/sdk
Why this package?
The Apps SDK "server side" is an MCP server. In Node, that is the MCP SDK.
Step 2: Widget template
Create public/todo-widget.html.
You can think of this as: "plain HTML, but with a window.openai object injected by ChatGPT".
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Todo list</title>
    <style>
      :root {
        color: #0b0b0f;
        font-family: system-ui, -apple-system, sans-serif;
      }
      body {
        margin: 0;
        padding: 16px;
        background: #f6f8fb;
      }
      main {
        max-width: 420px;
        margin: 0 auto;
        background: #fff;
        border-radius: 16px;
        padding: 16px;
      }
      form {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
      }
      input[type="text"] {
        flex: 1;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid #cad3e0;
      }
      button {
        border: none;
        border-radius: 10px;
        background: #111bf5;
        color: white;
        font-weight: 600;
        padding: 0 14px;
        cursor: pointer;
      }
      ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      li {
        background: #f2f4fb;
        border-radius: 12px;
        padding: 10px 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      li[data-completed="true"] span {
        text-decoration: line-through;
        color: #6c768a;
      }
    </style>
  </head>

  <body>
    <main>
      <h2 style="margin: 0 0 12px">Todo list</h2>

      <form id="add-form" autocomplete="off">
        <input id="todo-input" name="title" type="text" placeholder="Add a task" />
        <button type="submit">Add</button>
      </form>

      <ul id="todo-list"></ul>
    </main>

    <script type="module">
      const listEl = document.querySelector("#todo-list");
      const formEl = document.querySelector("#add-form");
      const inputEl = document.querySelector("#todo-input");

      // Apps SDK: ChatGPT injects the latest tool output into the widget under `window.openai.toolOutput`.
      // We read `tasks` from there to render the list.
      let tasks = window.openai?.toolOutput?.tasks ?? [];

      const render = () => {
        listEl.innerHTML = "";

        for (const task of tasks) {
          const li = document.createElement("li");
          li.dataset.id = task.id;
          li.dataset.completed = String(Boolean(task.completed));

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = Boolean(task.completed);
          checkbox.disabled = Boolean(task.completed);

          const label = document.createElement("span");
          label.textContent = task.title;

          li.appendChild(checkbox);
          li.appendChild(label);
          listEl.appendChild(li);
        }
      };

      // Apps SDK: when tools run (either by the model or by the widget), ChatGPT pushes updated globals.
      // This event is how your widget hears about updates, so you can re-render.
      window.addEventListener(
        "openai:set_globals",
        (event) => {
          const globals = event.detail?.globals;

          // We keep it simple: if tasks exist, swap and render.
          const nextTasks = globals?.toolOutput?.tasks;
          if (!nextTasks) return;

          tasks = nextTasks;
          render();
        },
        { passive: true }
      );

      // Apps SDK: widget can call tools directly via `window.openai.callTool(name, payload)`.
      // The tool returns the same structure the model sees (including structuredContent).
      const callTool = async (name, payload) => {
        const res = await window.openai.callTool(name, payload);

        // Minimal path: update UI if the tool returned tasks.
        if (res?.structuredContent?.tasks) {
          tasks = res.structuredContent.tasks;
          render();
        }
      };

      formEl.addEventListener("submit", async (event) => {
        event.preventDefault();
        const title = inputEl.value.trim();
        if (!title) return;

        await callTool("add_todo", { title });
        inputEl.value = "";
      });

      listEl.addEventListener("change", async (event) => {
        const checkbox = event.target;
        if (!(checkbox instanceof HTMLInputElement)) return;
        if (checkbox.type !== "checkbox") return;

        // This lab is one-way: once completed, you cannot uncomplete.
        if (!checkbox.checked) {
          checkbox.checked = true;
          return;
        }

        const id = checkbox.closest("li")?.dataset.id;
        if (!id) return;

        await callTool("complete_todo", { id });
      });

      render();
    </script>
  </body>
</html>
Notes on what is Apps SDK specific here:
window.openai.toolOutput (data the server returned)
openai:set_globals (how ChatGPT pushes updates to the widget)
window.openai.callTool(...) (widget calling MCP tools)
Step 3: MCP server
Create server.js.
This file:
creates an MCP server
registers a widget template
registers tools
exposes the MCP server over HTTP
import { createServer } from "node:http";
import { readFileSync } from "node:fs";

// Apps SDK: the MCP server implementation (Node).
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { z } from "zod";

const todoHtml = readFileSync("public/todo-widget.html", "utf8");

// Tiny in-memory "database" for the lab.
let todos = [];
let nextId = 1;

// Helper: tools return BOTH human text (content) and machine data (structuredContent).
// The widget reads `structuredContent.tasks` via `window.openai.toolOutput.tasks`.
const replyWithTodos = (message) => ({
  content: message ? [{ type: "text", text: message }] : [],
  structuredContent: { tasks: todos },
});

function createTodoServer() {
  // Apps SDK: MCP server identity. Shows up in logs and helps with debugging.
  const server = new McpServer({ name: "todo-app", version: "0.1.0" });

  // Apps SDK: register a widget TEMPLATE as a resource.
  //
  // Key bits:
  // - `mimeType: "text/html+skybridge"` tells ChatGPT this is a widget template.
  // - `uri` is what tools reference using `openai/outputTemplate`.
  server.registerResource("todo-widget", "ui://widget/todo.html", {}, async () => ({
    contents: [
      {
        uri: "ui://widget/todo.html",
        mimeType: "text/html+skybridge",
        text: todoHtml,
        _meta: { "openai/widgetPrefersBorder": true },
      },
    ],
  }));

  // Apps SDK: tool 1. Notice the `_meta` fields.
  //
  // - `openai/outputTemplate` points at our widget resource.
  //   This is what makes ChatGPT render the widget for tool results.
  // - `openai/widgetAccessible: true` allows the widget (front-end) to call this tool.
  server.registerTool(
    "add_todo",
    {
      title: "Add todo",
      description: "Create a todo item.",
      inputSchema: z.object({
        title: z.string().min(1),
      }),
      _meta: {
        "openai/outputTemplate": "ui://widget/todo.html",
        "openai/widgetAccessible": true,
        "openai/toolInvocation/invoking": "Adding todo",
        "openai/toolInvocation/invoked": "Added todo",
      },
    },
    async ({ title }) => {
      const taskTitle = String(title).trim();
      if (!taskTitle) return replyWithTodos("Missing title.");
      const task = { id: `todo-${nextId++}`, title: taskTitle, completed: false };
      todos = [...todos, task];
      return replyWithTodos(`Added "${task.title}".`);
    }
  );

  // Apps SDK: tool 2. Same pattern as above.
  server.registerTool(
    "complete_todo",
    {
      title: "Complete todo",
      description: "Mark a todo as completed by id.",
      inputSchema: z.object({
        id: z.string(),
      }),
      _meta: {
        "openai/outputTemplate": "ui://widget/todo.html",
        "openai/widgetAccessible": true,
        "openai/toolInvocation/invoking": "Completing todo",
        "openai/toolInvocation/invoked": "Completed todo",
      },
    },
    async ({ id }) => {
      const target = String(id);
      todos = todos.map((t) => (t.id === target ? { ...t, completed: true } : t));
      return replyWithTodos("Done.");
    }
  );

  return server;
}

const port = Number(process.env.PORT ?? 8787);
const MCP_PATH = "/mcp";

const httpServer = createServer(async (req, res) => {
  if (!req.url) {
    res.writeHead(400).end("Missing URL");
    return;
  }

  const url = new URL(req.url, `http://${req.headers.host ?? "localhost"}`);
  const isMcpRoute = url.pathname === MCP_PATH || url.pathname.startsWith(`${MCP_PATH}/`);

  // Minimal CORS so ChatGPT can call the server via HTTPS tunnel.
  if (req.method === "OPTIONS" && isMcpRoute) {
    res.writeHead(204, {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, GET, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "content-type, mcp-session-id",
      "Access-Control-Expose-Headers": "Mcp-Session-Id",
    });
    res.end();
    return;
  }

  if (req.method === "GET" && url.pathname === "/") {
    res.writeHead(200, { "content-type": "text/plain" }).end("Todo MCP server");
    return;
  }

  // Apps SDK: mount the MCP server over HTTP at /mcp.
  //
  // The StreamableHTTPServerTransport handles the MCP protocol over HTTP.
  // ChatGPT talks to this endpoint.
  const MCP_METHODS = new Set(["POST", "GET", "DELETE"]);
  if (isMcpRoute && req.method && MCP_METHODS.has(req.method)) {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Expose-Headers", "Mcp-Session-Id");

    const server = createTodoServer();
    const transport = new StreamableHTTPServerTransport({
      sessionIdGenerator: undefined, // stateless mode
      enableJsonResponse: true,
    });

    res.on("close", () => {
      transport.close();
      server.close();
    });

    try {
      await server.connect(transport);
      await transport.handleRequest(req, res);
    } catch (err) {
      console.error(err);
      if (!res.headersSent) res.writeHead(500).end("Internal server error");
    }
    return;
  }

  res.writeHead(404).end("Not Found");
});

httpServer.listen(port, () => {
  console.log(`Todo MCP server listening on http://localhost:${port}${MCP_PATH}`);
});
Step 4: Run and expose the server
node server.js
You should see:
Todo MCP server listening on http://localhost:8787/mcp
Expose it over HTTPS:
ngrok http 8787
Copy the public HTTPS URL and append /mcp.
Example: https://abcd-1234.ngrok.app/mcp
Step 5: Connect in ChatGPT
In ChatGPT: Settings -> Apps & Connectors -> enable Developer mode.
Create a new connector and paste your public HTTPS MCP URL (ending in /mcp).
Open a new chat, enable your connector, then try:
"Add a todo to buy oat milk"
"Mark the oat milk todo as done"
You should see the widget render and update as tools run.
Key takeaways
Tools return structuredContent. That is the data your widget is built around.
_meta["openai/outputTemplate"] makes the widget show up for tool output.
openai:set_globals and window.openai.toolOutput are how your widget stays in sync.
window.openai.callTool lets the widget call back into your server.
Challenge exercise (optional)
Add a third tool: clear_completed, and a button in the widget to call it.
Hint:
Tool returns updated { structuredContent: { tasks } }
Widget calls it with callTool("clear_completed", {})
Kitchen Sink Chat App
Goal: build a React based ChatGPT App end to end: an MCP server with tools, plus a widget UI bundled with Vite that renders inside ChatGPT.
Completion time: ~45 minutes.
What you'll build:
A React widget (web/) that uses window.openai globals and host UI APIs
A Node MCP server (server/) that:
exposes tools and a widget template
serves your built widget assets (JS and CSS)
demonstrates tool annotations and widget only metadata
A small "notes" app with:
tabs and routes (React Router)
persisted UI state (widgetState)
a debug panel that shows toolInput, toolOutput, and toolResponseMetadata
Prerequisites
Node.js 18+ installed
Access to ChatGPT Developer Mode (Settings -> Apps & Connectors -> Developer mode)
A way to expose a localhost over HTTPS (for example ngrok)
Step 0: Create the project folders
mkdir apps-sdk-kitchen-sink-lite
cd apps-sdk-kitchen-sink-lite
Step 1: Scaffold the React widget (Vite)
From the project root:
npm create vite@latest web -- --template react-ts
cd web
npm install
npm install react-router-dom
npm install -D @vitejs/plugin-react
This creates the web/ folder for you.
Step 1.1: Generate a build manifest for stable lookups
Create web/vite.config.ts or update it if it already exists:
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: "dist",
    emptyOutDir: true,
    manifest: true,
  },
});
Step 1.2: Add a tiny React hook to subscribe to Apps SDK globals
You have probably seen these in the Apps SDK docs and examples. They are small helpers you copy into your widget project so React can subscribe to host updates.
Important detail: these hooks are not "magically available" in your widget. You still include them in your bundle. The host provides window.openai and emits openai:set_globals when it updates globals.
Create web/src/openai-bridge.ts:
import { useSyncExternalStore } from "react";

declare global {
  interface Window {
    openai: any;
  }
}

const EVENT = "openai:set_globals";

type SetGlobalsEvent = CustomEvent<{ globals: Record<string, unknown> }>;

export function useOpenAiGlobal<T = any>(key: string): T {
  return useSyncExternalStore(
    (onChange) => {
      const handler = (event: Event) => {
        const e = event as SetGlobalsEvent;
        if (e.detail?.globals?.[key] === undefined) return;
        onChange();
      };

      window.addEventListener(EVENT, handler, { passive: true });
      return () => window.removeEventListener(EVENT, handler);
    },
    () => window.openai?.[key] as T
  );
}

export const useToolInput = <T = any>() => useOpenAiGlobal<T>("toolInput");
export const useToolOutput = <T = any>() => useOpenAiGlobal<T>("toolOutput");
export const useToolResponseMetadata = <T = any>() => useOpenAiGlobal<T>("toolResponseMetadata");
export const useWidgetState = <T = any>() => useOpenAiGlobal<T>("widgetState");
export const useTheme = <T = any>() => useOpenAiGlobal<T>("theme");
export const useDisplayMode = <T = any>() => useOpenAiGlobal<T>("displayMode");
Apps SDK specific bits:
ChatGPT pushes updated globals into your iframe and fires openai:set_globals.
This hook makes React re-render by subscribing to that event and reading window.openai[key].
Step 1.3: Build the widget UI
Replace web/src/App.tsx with:
import { useEffect, useMemo, useRef, useState } from "react";
import { HashRouter, Link, Route, Routes, useNavigate, useParams } from "react-router-dom";
import {
  useDisplayMode,
  useTheme,
  useToolInput,
  useToolOutput,
  useToolResponseMetadata,
  useWidgetState,
} from "./openai-bridge";

type Note = { id: string; text: string; createdAt: string };
type Snapshot = { now: string; counter: number; notes: Note[] };

function pretty(x: unknown) {
  return JSON.stringify(x ?? {}, null, 2);
}

function newRequestId() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }

  return `${Date.now()}-${Math.random().toString(36).slice(2)}`;
}

function useIntrinsicHeight() {
  const rootRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const el = rootRef.current;
    if (!el) return;

    const ro = new ResizeObserver(() => {
      const height = el.scrollHeight;
      window.openai?.notifyIntrinsicHeight?.({ height });
    });

    ro.observe(el);
    return () => ro.disconnect();
  }, []);

  return rootRef;
}

function TopBar() {
  const theme = useTheme<string>();
  const mode = useDisplayMode<string>();
  const meta = useToolResponseMetadata<{ banner?: string; requestId?: string }>() ?? {};

  async function refresh() {
    await window.openai?.callTool?.("refresh_snapshot", {});
  }

  async function goInline() {
    await window.openai?.requestDisplayMode?.({ mode: "inline" });
  }

  async function goPip() {
    await window.openai?.requestDisplayMode?.({ mode: "pip" });
  }

  async function goFullscreen() {
    await window.openai?.requestDisplayMode?.({ mode: "fullscreen" });
  }

  async function openDocs() {
    await window.openai?.openExternal?.({ href: "https://developers.openai.com/" });
  }

  async function askChatGPT() {
    await window.openai?.sendFollowUpMessage?.({
      prompt: "Summarise the notes in my widget and suggest next actions.",
    });
  }

  return (
    <div style={{ display: "flex", alignItems: "baseline", justifyContent: "space-between", gap: 12 }}>
      <div>
        <div style={{ fontSize: 16, fontWeight: 700 }}>Kitchen Sink Lite</div>
        <div style={{ fontSize: 12, opacity: 0.75 }}>
          {meta.banner ?? "Apps SDK playground"} {meta.requestId ? `| ${meta.requestId}` : ""}
        </div>
        <div style={{ fontSize: 12, opacity: 0.6 }}>theme: {theme ?? "?"} | mode: {mode ?? "?"}</div>
      </div>

      <div style={{ display: "flex", gap: 8, flexWrap: "wrap", justifyContent: "flex-end" }}>
        <button onClick={refresh}>Refresh</button>
        <button onClick={goInline}>Inline</button>
        <button onClick={goPip}>PiP</button>
        <button onClick={goFullscreen}>Fullscreen</button>
        <button onClick={openDocs}>Docs</button>
        <button onClick={askChatGPT}>Ask ChatGPT</button>
      </div>
    </div>
  );
}

function Tabs() {
  const widgetState = useWidgetState<{ tab?: string; draft?: string }>() ?? {};
  const tab = widgetState.tab ?? "overview";

  function setTab(next: string) {
    window.openai?.setWidgetState?.({ ...widgetState, tab: next });
  }

  return (
    <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
      <button onClick={() => setTab("overview")} data-active={tab === "overview"}>Overview</button>
      <button onClick={() => setTab("notes")} data-active={tab === "notes"}>Notes</button>
      <button onClick={() => setTab("debug")} data-active={tab === "debug"}>Debug</button>
    </div>
  );
}

function Overview() {
  const toolOutput = useToolOutput<Snapshot>() ?? { now: "", counter: 0, notes: [] };
  const navigate = useNavigate();

  return (
    <div style={{ marginTop: 12 }}>
      <div style={{ display: "flex", gap: 16, flexWrap: "wrap" }}>
        <div>
          <div style={{ fontSize: 12, opacity: 0.75 }}>Server time</div>
          <div style={{ fontWeight: 600 }}>{toolOutput.now || "-"}</div>
        </div>
        <div>
          <div style={{ fontSize: 12, opacity: 0.75 }}>Counter</div>
          <div style={{ fontWeight: 600 }}>{toolOutput.counter}</div>
        </div>
        <div>
          <div style={{ fontSize: 12, opacity: 0.75 }}>Notes</div>
          <div style={{ fontWeight: 600 }}>{toolOutput.notes.length}</div>
        </div>
      </div>

      <div style={{ marginTop: 12 }}>
        <div style={{ fontSize: 12, opacity: 0.75, marginBottom: 6 }}>Quick nav</div>
        <div style={{ display: "flex", gap: 12, flexWrap: "wrap" }}>
          <Link to="/notes">Go to notes page</Link>
          <a
            href="#"
            onClick={(e) => {
              e.preventDefault();
              navigate("/note/latest");
            }}
          >
            Open latest note
          </a>
        </div>
      </div>
    </div>
  );
}

function NotesTab() {
  const toolOutput = useToolOutput<Snapshot>() ?? { now: "", counter: 0, notes: [] };
  const widgetState = useWidgetState<{ tab?: string; draft?: string }>() ?? {};

  const [draft, setDraft] = useState(widgetState.draft ?? "");

  useEffect(() => {
    setDraft(widgetState.draft ?? "");
  }, [widgetState.draft]);

  function setDraftState(next: string) {
    setDraft(next);
    window.openai?.setWidgetState?.({ ...widgetState, draft: next });
  }

  async function addNote() {
    const text = draft.trim();
    if (!text) return;

    await window.openai?.callTool?.("add_note", { text, requestId: newRequestId() });
    await window.openai?.callTool?.("refresh_snapshot", {});
    window.openai?.setWidgetState?.({ ...widgetState, draft: "" });
  }

  async function clearNotes() {
    await window.openai?.callTool?.("clear_notes", {});
    await window.openai?.callTool?.("refresh_snapshot", {});
  }

  return (
    <div style={{ marginTop: 12 }}>
      <div style={{ display: "flex", gap: 8 }}>
        <input
          value={draft}
          placeholder="Write a note..."
          onChange={(e) => setDraftState(e.target.value)}
          style={{ flex: 1, padding: 8 }}
        />
        <button onClick={addNote}>Add</button>
        <button onClick={clearNotes}>Clear</button>
      </div>

      <div style={{ marginTop: 12 }}>
        {toolOutput.notes.length === 0 ? (
          <div style={{ opacity: 0.75 }}>No notes yet.</div>
        ) : (
          <ul>
            {toolOutput.notes.map((n) => (
              <li key={n.id}>
                <Link to={`/note/${encodeURIComponent(n.id)}`}>{n.text}</Link>{" "}
                <span style={{ opacity: 0.6, fontSize: 12 }}>({n.createdAt})</span>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

function DebugTab() {
  const toolInput = useToolInput();
  const toolOutput = useToolOutput();
  const toolMeta = useToolResponseMetadata();
  const widgetState = useWidgetState();

  return (
    <div style={{ marginTop: 12 }}>
      <div style={{ fontSize: 12, opacity: 0.75 }}>toolInput</div>
      <pre style={{ fontSize: 12, padding: 8, background: "rgba(0,0,0,0.05)", overflowX: "auto" }}>{pretty(toolInput)}</pre>

      <div style={{ fontSize: 12, opacity: 0.75, marginTop: 8 }}>toolOutput (structuredContent)</div>
      <pre style={{ fontSize: 12, padding: 8, background: "rgba(0,0,0,0.05)", overflowX: "auto" }}>{pretty(toolOutput)}</pre>

      <div style={{ fontSize: 12, opacity: 0.75, marginTop: 8 }}>toolResponseMetadata (_meta)</div>
      <pre style={{ fontSize: 12, padding: 8, background: "rgba(0,0,0,0.05)", overflowX: "auto" }}>{pretty(toolMeta)}</pre>

      <div style={{ fontSize: 12, opacity: 0.75, marginTop: 8 }}>widgetState</div>
      <pre style={{ fontSize: 12, padding: 8, background: "rgba(0,0,0,0.05)", overflowX: "auto" }}>{pretty(widgetState)}</pre>
    </div>
  );
}

function Home() {
  const widgetState = useWidgetState<{ tab?: string; draft?: string }>() ?? {};
  const tab = widgetState.tab ?? "overview";

  return (
    <div style={{ fontFamily: "ui-sans-serif, system-ui", padding: 12 }}>
      <TopBar />
      <Tabs />

      {tab === "overview" && <Overview />}
      {tab === "notes" && <NotesTab />}
      {tab === "debug" && <DebugTab />}
    </div>
  );
}

function NotesPage() {
  const toolOutput = useToolOutput<Snapshot>() ?? { now: "", counter: 0, notes: [] };

  return (
    <div style={{ padding: 12 }}>
      <div style={{ fontWeight: 700 }}>Notes (route demo)</div>
      <div style={{ marginTop: 8 }}>
        <Link to="/">Back</Link>
      </div>
      <ul style={{ marginTop: 12 }}>
        {toolOutput.notes.map((n) => (
          <li key={n.id}>
            <Link to={`/note/${encodeURIComponent(n.id)}`}>{n.text}</Link>
          </li>
        ))}
      </ul>
    </div>
  );
}

function NoteDetails() {
  const { id } = useParams();
  const toolOutput = useToolOutput<Snapshot>() ?? { now: "", counter: 0, notes: [] };

  const note = useMemo(() => {
    if (!id) return null;
    if (id === "latest") return toolOutput.notes.at(-1) ?? null;
    return toolOutput.notes.find((n) => n.id === id) ?? null;
  }, [toolOutput, id]);

  return (
    <div style={{ padding: 12 }}>
      <div style={{ fontWeight: 700 }}>Note details</div>
      <div style={{ marginTop: 8 }}>
        <Link to="/">Back</Link>
      </div>
      <div style={{ marginTop: 12 }}>
        {note ? (
          <>
            <div style={{ fontWeight: 600 }}>{note.text}</div>
            <div style={{ opacity: 0.6, fontSize: 12 }}>{note.createdAt}</div>
          </>
        ) : (
          <div style={{ opacity: 0.75 }}>Not found.</div>
        )}
      </div>
    </div>
  );
}

export default function App() {
  const rootRef = useIntrinsicHeight();

  return (
    <div ref={rootRef}>
      <HashRouter>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/notes" element={<NotesPage />} />
          <Route path="/note/:id" element={<NoteDetails />} />
          <Route path="*" element={<Home />} />
        </Routes>
      </HashRouter>
    </div>
  );
}
Checkpoint: your widget compiles locally.
npm run build
You should see:
web/dist/assets/index-*.js
web/dist/assets/index-*.css
Step 2: Build the MCP server and serve widget assets
From the web/ folder:
mkdir -p ../server
cd ../server
npm init -y
npm install @modelcontextprotocol/sdk zod
Update server/package.json:
{
  "type": "module",
  "scripts": {
    "start": "node index.js"
  }
}
Create server/index.js:
import { createServer } from "node:http";
import { readFileSync, existsSync } from "node:fs";
import { join, extname } from "node:path";
import { randomUUID } from "node:crypto";
import { z } from "zod";

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";

const PORT = Number(process.env.PORT ?? 8787);
const MCP_PATH = "/mcp";

// Public base URL that ChatGPT can fetch assets from.
// In dev, set this to your HTTPS tunnel origin (for example https://xxxx.ngrok.app)
const BASE_URL = process.env.BASE_URL ?? `http://localhost:${PORT}`;
const BASE_ORIGIN = new URL(BASE_URL).origin;

// Vite build output lives here:
const DIST_DIR = join(process.cwd(), "..", "web", "dist");
const WIDGET_URI = "ui://widget/kitchen-sink.html";

function contentTypeFor(pathname) {
  const ext = extname(pathname);
  if (ext === ".js") return "text/javascript; charset=utf-8";
  if (ext === ".css") return "text/css; charset=utf-8";
  if (ext === ".map") return "application/json; charset=utf-8";
  if (ext === ".json") return "application/json; charset=utf-8";
  if (ext === ".svg") return "image/svg+xml; charset=utf-8";
  if (ext === ".png") return "image/png";
  if (ext === ".jpg" || ext === ".jpeg") return "image/jpeg";
  if (ext === ".webp") return "image/webp";
  return "application/octet-stream";
}

function loadViteManifest() {
  const manifestPath = join(DIST_DIR, ".vite", "manifest.json");
  return JSON.parse(readFileSync(manifestPath, "utf8"));
}

function getViteEntry(manifest) {
  const entry = Object.values(manifest).find((x) => x && x.isEntry);
  if (!entry) throw new Error("No Vite entry found in manifest.json");
  return entry;
}

function allowOriginHeader(req) {
  // Widgets and module scripts can be fetched with `Origin: null`.
  // Echoing the Origin when present is the most compatible behavior.
  const origin = req.headers.origin;
  return origin ? String(origin) : "*";
}

function applyCors(res, req) {
  res.setHeader("Access-Control-Allow-Origin", allowOriginHeader(req));
  if (req.headers.origin) res.setHeader("Vary", "Origin");
}

function shouldInlineWidgetAssets() {
  // ngrok free domains can inject an interstitial warning page (ERR_NGROK_6024)
  // for subresource requests. That breaks external <script src="..."> inside the
  // ChatGPT widget because the "JS" response is actually HTML.
  //
  // If you are using ngrok-free domains, inlining is the simplest workaround.
  const env = process.env.INLINE_WIDGET_ASSETS;
  if (env === "1") return true;
  if (env === "0") return false;
  return (
    BASE_ORIGIN.includes("ngrok-free.app") ||
    BASE_ORIGIN.includes("ngrok-free.dev")
  );
}

function escapeInlineScript(code) {
  return String(code).replaceAll("</script>", "<\\/script>");
}

function escapeInlineStyle(code) {
  return String(code).replaceAll("</style>", "<\\/style>");
}

function missingBuildHtml(message) {
  return `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body { font: 14px ui-sans-serif, system-ui; padding: 12px; }
      code, pre { font: 12px ui-monospace, SFMono-Regular, Menlo, monospace; }
      pre { background: rgba(0,0,0,0.06); padding: 10px; overflow-x: auto; }
    </style>
  </head>
  <body>
    <h3>Kitchen Sink Lite</h3>
    <p>${message}</p>
    <pre>Expected Vite build output at:
${DIST_DIR}</pre>
  </body>
</html>`;
}

function widgetHtml() {
  let entry;
  try {
    const manifest = loadViteManifest();
    entry = getViteEntry(manifest);
  } catch (err) {
    return missingBuildHtml(
      "Widget bundle not found. Run `npm run build` in ../web and restart the server.",
    );
  }

  const inlineAssets = shouldInlineWidgetAssets();

  let cssTags = "";
  let scriptTag = "";

  try {
    if (inlineAssets) {
      const js = readFileSync(join(DIST_DIR, entry.file), "utf8");
      const cssList = (entry.css ?? []).map((href) =>
        readFileSync(join(DIST_DIR, href), "utf8"),
      );

      cssTags = cssList
        .map((css) => `<style>${escapeInlineStyle(css)}</style>`)
        .join("\n");
      scriptTag = `<script type="module">${escapeInlineScript(js)}</script>`;
    } else {
      cssTags = (entry.css ?? [])
        .map((href) => `<link rel="stylesheet" href="${BASE_URL}/${href}">`)
        .join("\n");
      scriptTag = `<script type="module" src="${BASE_URL}/${entry.file}"></script>`;
    }
  } catch (err) {
    return missingBuildHtml(
      "Failed to read the built widget assets from disk. Rebuild the web app and restart the server.",
    );
  }

  return `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    ${cssTags}
    <style>
      button[data-active="true"] { font-weight: 700; }
      button { padding: 6px 10px; }
      a { color: inherit; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    ${scriptTag}
  </body>
</html>`;
}

// Tiny in-memory state for the lab.
let counter = 0;
let notes = [];
const noteRequestIds = new Map();
const noteFallbackIds = new Map();
const NOTE_REQUEST_TTL_MS = 5 * 60 * 1000;
const NOTE_FALLBACK_TTL_MS = 3 * 1000;

function snapshot() {
  return {
    now: new Date().toISOString(),
    counter,
    notes,
  };
}

function pruneMap(map, ttlMs, now) {
  for (const [id, ts] of map) {
    if (now - ts > ttlMs) map.delete(id);
  }
}

function createServerInstance() {
  const server = new McpServer({ name: "kitchen-sink-lite", version: "0.1.0" });

  // Apps SDK: register the widget template.
  server.registerResource("kitchen-sink-widget", WIDGET_URI, {}, async () => ({
    contents: [
      {
        uri: WIDGET_URI,
        mimeType: "text/html+skybridge",
        text: widgetHtml(),
        _meta: {
          "openai/widgetPrefersBorder": true,

          // Allow the widget to load JS/CSS from your server origin.
          "openai/widgetCSP": {
            resource_domains: [BASE_ORIGIN],
            connect_domains: [BASE_ORIGIN],
          },
        },
      },
    ],
  }));

  // Tool 1: open the widget (model-facing entry point).
  server.registerTool(
    "open_kitchen_sink",
    {
      title: "Open Kitchen Sink Lite",
      description: "Open a small Apps SDK playground widget.",
      inputSchema: z.object({}).strict(),
      annotations: { readOnlyHint: true },
      _meta: {
        "openai/outputTemplate": WIDGET_URI,
        "openai/toolInvocation/invoking": "Opening the widget",
        "openai/toolInvocation/invoked": "Opened",
      },
    },
    async () => ({
      content: [{ type: "text", text: "Opened the Kitchen Sink Lite widget." }],
      structuredContent: snapshot(),
      _meta: {
        banner: "Everything here is powered by window.openai",
        requestId: randomUUID(),
      },
    }),
  );

  // Tool 2: refresh data (widget and model can call it).
  server.registerTool(
    "refresh_snapshot",
    {
      title: "Refresh snapshot",
      description: "Refresh the current server snapshot.",
      inputSchema: z.object({}).strict(),
      annotations: { readOnlyHint: true },
      _meta: {
        "openai/outputTemplate": WIDGET_URI,
        "openai/widgetAccessible": true,
        "openai/toolInvocation/invoking": "Refreshing",
        "openai/toolInvocation/invoked": "Refreshed",
      },
    },
    async () => ({
      content: [{ type: "text", text: "Refreshed." }],
      structuredContent: snapshot(),
      _meta: { banner: "Refreshed data from server", requestId: randomUUID() },
    }),
  );

  // Tool 3: add a note (widget calls this).
  server.registerTool(
    "add_note",
    {
      title: "Add note",
      description: "Add a short note.",
      // Be liberal in what we accept: some clients historically sent `{ note: "..." }`
      // instead of `{ text: "..." }`. Keep the tool schema strict (no unknown keys),
      // but allow either key and validate at least one is present.
      inputSchema: z
        .object({
          text: z.string().optional(),
          note: z.string().optional(),
          requestId: z.string().min(1).optional(),
        })
        .strict()
        .refine((v) => (v.text ?? v.note)?.trim().length, {
          message: "Expected `text` (string) or `note` (string).",
        }),
      annotations: {
        readOnlyHint: false,
        destructiveHint: false,
        openWorldHint: false,
        idempotentHint: true,
      },
      _meta: {
        "openai/outputTemplate": WIDGET_URI,
        "openai/widgetAccessible": true,
        "openai/toolInvocation/invoking": "Adding note",
        "openai/toolInvocation/invoked": "Added",
      },
    },
    async ({ text, note, requestId }) => {
      const t = String(text ?? note).trim();
      const now = Date.now();
      pruneMap(noteRequestIds, NOTE_REQUEST_TTL_MS, now);
      pruneMap(noteFallbackIds, NOTE_FALLBACK_TTL_MS, now);

      if (requestId) {
        if (noteRequestIds.has(requestId)) {
          return {
            content: [{ type: "text", text: "Added a note." }],
            structuredContent: snapshot(),
            _meta: { banner: "Note already recorded", requestId: randomUUID() },
          };
        }
        noteRequestIds.set(requestId, now);
      } else {
        const fallbackKey = `text:${t.toLowerCase()}`;
        if (noteFallbackIds.has(fallbackKey)) {
          return {
            content: [{ type: "text", text: "Added a note." }],
            structuredContent: snapshot(),
            _meta: { banner: "Note already recorded", requestId: randomUUID() },
          };
        }
        noteFallbackIds.set(fallbackKey, now);
      }

      notes = [
        ...notes,
        { id: randomUUID(), text: t, createdAt: new Date().toISOString() },
      ];
      counter += 1;

      return {
        content: [{ type: "text", text: "Added a note." }],
        structuredContent: snapshot(),
        _meta: { banner: "Note saved on server", requestId: randomUUID() },
      };
    },
  );

  // Tool 4: clear notes (destructive UX hint).
  server.registerTool(
    "clear_notes",
    {
      title: "Clear notes",
      description: "Delete all notes.",
      inputSchema: z.object({}).strict(),
      annotations: { destructiveHint: true, idempotentHint: true },
      _meta: {
        "openai/outputTemplate": WIDGET_URI,
        "openai/widgetAccessible": true,
        "openai/toolInvocation/invoking": "Clearing notes",
        "openai/toolInvocation/invoked": "Cleared",
      },
    },
    async () => {
      notes = [];
      return {
        content: [{ type: "text", text: "Cleared notes." }],
        structuredContent: snapshot(),
        _meta: { banner: "All notes removed", requestId: randomUUID() },
      };
    },
  );

  // Tool 5: widget-only debug tool (model cannot see it).
  server.registerTool(
    "get_debug_context",
    {
      title: "Get debug context",
      description: "Return widget-only debug details.",
      inputSchema: z.object({}).strict(),
      annotations: { readOnlyHint: true },
      _meta: {
        "openai/outputTemplate": WIDGET_URI,
        "openai/widgetAccessible": true,
        "openai/visibility": "private",
      },
    },
    async () => ({
      content: [],
      structuredContent: snapshot(),
      _meta: {
        banner: "Widget-only debug context",
        requestId: randomUUID(),
        serverPid: process.pid,
      },
    }),
  );

  return server;
}

const httpServer = createServer(async (req, res) => {
  if (!req.url) {
    res.writeHead(400).end("Missing URL");
    return;
  }

  // Set on all responses so errors do not get masked as "CORS failed".
  applyCors(res, req);

  const url = new URL(req.url, `http://${req.headers.host ?? "localhost"}`);
  const isMcpRoute =
    url.pathname === MCP_PATH || url.pathname.startsWith(`${MCP_PATH}/`);

  // CORS preflight for Vite assets (some widget hosts fetch assets with preflight).
  if (req.method === "OPTIONS" && url.pathname.startsWith("/assets/")) {
    const reqHeaders = req.headers["access-control-request-headers"];
    res.statusCode = 204;
    res.setHeader("Access-Control-Allow-Methods", "GET, OPTIONS");
    res.setHeader(
      "Access-Control-Allow-Headers",
      reqHeaders ? String(reqHeaders) : "content-type",
    );
    res.end();
    return;
  }

  // Serve Vite assets (hashed filenames) from web/dist/assets
  if (req.method === "GET" && url.pathname.startsWith("/assets/")) {
    // Strip the leading "/" so join() stays under DIST_DIR
    const relPath = url.pathname.slice(1); // "assets/..."
    const filePath = join(DIST_DIR, relPath);

    res.setHeader("Cross-Origin-Resource-Policy", "cross-origin");

    if (!existsSync(filePath)) {
      res.statusCode = 404;
      res.end("Not Found");
      return;
    }

    const body = readFileSync(filePath);
    res.setHeader("content-type", contentTypeFor(filePath));
    res.statusCode = 200;
    res.end(body);
    return;
  }

  if (req.method === "GET" && url.pathname === "/") {
    res.writeHead(200, { "content-type": "text/plain; charset=utf-8" });
    res.end("Kitchen Sink Lite MCP server");
    return;
  }

  // CORS preflight for MCP
  if (req.method === "OPTIONS" && isMcpRoute) {
    const reqHeaders = req.headers["access-control-request-headers"];
    res.statusCode = 204;
    res.setHeader("Access-Control-Allow-Methods", "POST, GET, DELETE, OPTIONS");
    res.setHeader(
      "Access-Control-Allow-Headers",
      reqHeaders ? String(reqHeaders) : "content-type, mcp-session-id",
    );
    res.setHeader("Access-Control-Expose-Headers", "Mcp-Session-Id");
    res.end();
    return;
  }

  const MCP_METHODS = new Set(["POST", "GET", "DELETE"]);
  if (isMcpRoute && req.method && MCP_METHODS.has(req.method)) {
    res.setHeader("Access-Control-Expose-Headers", "Mcp-Session-Id");

    const server = createServerInstance();
    const transport = new StreamableHTTPServerTransport({
      sessionIdGenerator: undefined,
      enableJsonResponse: true,
    });

    res.on("close", () => {
      transport.close();
      server.close();
    });

    try {
      await server.connect(transport);
      await transport.handleRequest(req, res);
    } catch (err) {
      console.error(err);
      if (!res.headersSent) res.writeHead(500).end("Internal server error");
    }
    return;
  }

  res.writeHead(404).end("Not Found");
});

httpServer.listen(PORT, () => {
  let entryFile = "(build web/ first)";
  try {
    const manifest = loadViteManifest();
    entryFile = getViteEntry(manifest).file;
  } catch {}

  console.log(`MCP endpoint: ${BASE_URL}${MCP_PATH}`);
  console.log(`Vite entry:   ${BASE_URL}/${entryFile}`);
  console.log(`BASE_URL:     ${BASE_URL}`);
  console.log(
    `Widget assets: ${shouldInlineWidgetAssets() ? "inline" : "external"} (set INLINE_WIDGET_ASSETS=1 to force inline)`,
  );
});
Checkpoint: server boots.
npm start
Step 3: Run it behind HTTPS
Build the widget:
cd ../web
npm run build
Start an HTTPS tunnel to your server port:
ngrok http 8787
Copy the public HTTPS URL, for example:
https://abcd-1234.ngrok-free.app
Note on ngrok-free: ngrok injects an interstitial warning page for subresource requests, which breaks module script loads inside the widget. This lab detects ngrok-free domains and inlines the built JS/CSS into the widget HTML to avoid that. You can force this behavior with INLINE_WIDGET_ASSETS=1, or use a different tunnel provider to keep external asset loading.
Start the server with BASE_URL set to that tunnel origin:
cd ../server
BASE_URL=https://abcd-1234.ngrok-free.app npm start
Step 4: Connect ChatGPT to your MCP server
In ChatGPT, enable Developer Mode.
Add a connector pointing at your MCP URL:
URL: https://abcd-1234.ngrok-free.app/mcp
Transport: Streamable HTTP
Start a new chat with the connector enabled.
Test prompt:
"Open Kitchen Sink Lite"
Checkpoint: you see a widget with tabs and buttons.
Step 5: Understanding what's happening
Read these sections in your code and make sure you can point to them:
Widget side:
React subscription: useOpenAiGlobal listens for openai:set_globals
Shared state: window.openai.toolOutput is the tool structuredContent
Widget only metadata: window.openai.toolResponseMetadata is tool result _meta
Persisted UI state: window.openai.widgetState and window.openai.setWidgetState(...)
Host UI APIs: requestDisplayMode, openExternal, sendFollowUpMessage, notifyIntrinsicHeight
Server side:
Widget template registration: registerResource(... mimeType: "text/html+skybridge")
Tool to widget wiring: _meta["openai/outputTemplate"] = "ui://widget/kitchen-sink.html"
Widget initiated tool calls: _meta["openai/widgetAccessible"] = true
Private tool: _meta["openai/visibility"] = "private"
Tool UX hints: annotations (readOnlyHint, destructiveHint, idempotentHint)
Idempotent tool calls: add_note uses optional requestId to dedupe retries
Checkpoint: you can explain, in one sentence each:
what belongs in structuredContent vs _meta vs widgetState
why you needed openai/widgetCSP once you started loading external JS and CSS (not required when inlining)
Challenge exercises (optional)
Challenge A: Make the debug tool show up in the widget (and only the widget)
Add a button in the Debug tab that calls:
await window.openai.callTool("get_debug_context", {});
Then display the returned _meta in the UI. Confirm the model does not call this tool on its own.
Challenge B: Add a modal confirm for "Clear"
Before calling clear_notes, open a host modal and only proceed if confirmed.
Challenge C: Key server state by MCP session id
Right now, everyone hitting your server shares the same notes array. Make state per session:
Read the mcp-session-id request header
Store { counter, notes } in a Map<sessionId, state>
This is a good practical MCP pattern.
Challenge D: Add a "read only" tool the model can call
Add a tool like summarise_notes that returns a short content summary only (still attach the widget outputTemplate so the widget stays visible).
Troubleshooting
Widget is blank, or JS fails to load:
Confirm BASE_URL matches your tunnel origin
Confirm the resource _meta["openai/widgetCSP"] allowlists the origin
Confirm /assets/index-*.js and /assets/index-*.css are reachable over HTTPS
If you see an ngrok warning HTML response (ERR_NGROK_6024), set INLINE_WIDGET_ASSETS=1
Tools run but the widget does not update:
Confirm you are returning structuredContent from tools
Confirm your React UI reads from useToolOutput() (which reads window.openai.toolOutput)
Confirm your hook subscribes to openai:set_globals
Buttons do nothing in the widget:
Confirm tool metadata includes "openai/widgetAccessible": true
Check the widget console for errors